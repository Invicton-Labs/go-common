package log

import (
	"github.com/Invicton-Labs/go-common/collections"
	"github.com/Invicton-Labs/go-stackerr"
	"go.uber.org/multierr"
	"go.uber.org/zap/zapcore"
)

type ZapWriteHook func(e zapcore.Entry, logFields map[string]zapcore.Field, errs []StackError, stacktraces stackerr.Stacks) stackerr.Error

type stackTrace struct {
	stack       stackerr.Stack
	useAsCaller bool
}

type StackError struct {
	Key         string          `json:"key,omitempty"`
	Fields      map[string]any  `json:"fields,omitempty"`
	Message     string          `json:"message,omitempty"`
	Stacktraces stackerr.Stacks `json:"stacktraces,omitempty"`
}

type core struct {
	zapcore.LevelEnabler
	name          string
	enc           zapcore.Encoder
	out           zapcore.WriteSyncer
	isJson        bool
	fields        map[string]zapcore.Field
	getWriteHooks func() map[string]ZapWriteHook

	// Tracking of errors and stacks
	stacks []stackTrace
	errs   []StackError
}

func (c *core) clone() *core {
	return &core{
		LevelEnabler:  c.LevelEnabler,
		name:          c.name,
		enc:           c.enc.Clone(),
		out:           c.out,
		fields:        collections.CopyMap(c.fields),
		getWriteHooks: c.getWriteHooks,
		isJson:        c.isJson,
		stacks:        collections.CopySlice(c.stacks),
		errs:          collections.CopySlice(c.errs),
	}
}

func (c *core) With(fields []zapcore.Field) zapcore.Core {
	// Always clone the core when adding new fields
	c = c.clone()

	// Loop through each field
	for _, field := range fields {
		if field.Interface != nil {
			// Check if it's any type of error
			if err, ok := field.Interface.(error); ok {
				// Check if it's a StackErr
				if serr, ok := field.Interface.(stackerr.Error); ok {
					// If so, add it with the error, stacktraces, and fields
					c.errs = append([]StackError{{
						Key:         field.Key,
						Fields:      serr.Fields(),
						Message:     serr.Error(),
						Stacktraces: serr.Stacks(),
					}}, c.errs...)
				} else {
					// Otherwise, add it without stacktraces or fields
					c.errs = append([]StackError{{
						Key:     field.Key,
						Message: err.Error(),
					}}, c.errs...)
				}
				continue
			} else if stack, ok := field.Interface.(stackTrace); ok {
				c.stacks = append([]stackTrace{stack}, c.stacks...)
				continue
			}
		}

		// Otherwise, add it normally
		c.fields[field.Key] = field
		field.AddTo(c.enc)
	}

	return c
}

func (c *core) Check(ent zapcore.Entry, ce *zapcore.CheckedEntry) *zapcore.CheckedEntry {
	if c.Enabled(ent.Level) {
		return ce.AddCore(ent, c)
	}
	return ce
}

func (c *core) Write(ent zapcore.Entry, fields []zapcore.Field) error {

	stackErrs := c.errs

	logFields := collections.CopyMap(c.fields)

	// Loop through all fields in this Write to extract any errors
	for _, field := range fields {
		if field.Interface != nil {
			if err, ok := field.Interface.(error); ok {
				if serr, ok := field.Interface.(stackerr.Error); ok {
					stackErrs = append([]StackError{{
						Key:         field.Key,
						Fields:      serr.Fields(),
						Message:     serr.Error(),
						Stacktraces: serr.Stacks(),
					}}, stackErrs...)
				} else {
					stackErrs = append([]StackError{{
						Key:     field.Key,
						Message: err.Error(),
					}}, stackErrs...)
				}
				// Mark it as a field to be skipped, since
				// we're tracking the errors separately.
				field.Type = zapcore.SkipType
				continue
			}
		}
		logFields[field.Key] = field
	}

	if ent.Level > zapcore.ErrorLevel {
		// Since we may be crashing the program, sync the output. Ignore Sync
		// errors, pending a clean solution to issue #370.
		defer c.Sync()
	}

	// Now that we have a copy of the content without the errors field,
	// add the errors field.
	if len(stackErrs) > 0 {
		fields = append(fields, zapcore.Field{
			Key:       "errors",
			Type:      zapcore.ReflectType,
			Interface: stackErrs,
		})
	}

	var callerOverride zapcore.EntryCaller
	var stacktraces stackerr.Stacks

	// Check if there should be a stack trace
	if ent.Stack != "" {

		// Track all stack traces that we find
		stacktraces = make(stackerr.Stacks, 0, len(c.stacks))

		// Start with explicit stack traces
		for _, stack := range c.stacks {
			stacktraces = append(stacktraces, stack.stack)
			if stack.useAsCaller && !callerOverride.Defined {
				callerOverride = zapcore.EntryCaller{
					Defined:  true,
					PC:       stack.stack[0].PC,
					Function: stack.stack[0].Function,
					File:     stack.stack[0].File,
					Line:     stack.stack[0].Line,
				}
			}
		}

		if len(stacktraces) == 0 {
			// If there are no stacks, parse the one generated by Zap
			stacktraces = stackerr.ParseStacks(ent.Stack)
		} else {
			// Otherwise, eliminate any duplicate stacks
			stacktraces = stacktraces.Distinct()
		}

		// There should be a stack trace included
		if c.isJson {
			// Eliminate the regular stacktrace field, since it always
			// encodes as a string. We want it to remain in structured JSON.
			ent.Stack = ""

			// Add a field that will encode to structured JSON.
			fields = append(fields, zapcore.Field{
				Key:       "stacktraces",
				Type:      zapcore.ReflectType,
				Interface: stacktraces,
			})
		} else {
			ent.Stack = stacktraces.Format()
		}
	}

	// If we specified a stack that is supposed to override our
	// caller, do that override here.
	if ent.Caller.Defined && callerOverride.Defined {
		ent.Caller = callerOverride
	}

	// Encode the entry
	buf, err := c.enc.EncodeEntry(ent, fields)
	if err != nil {
		return err
	}
	defer buf.Free()

	errs := []error{}

	// Write it out to our main output
	if c.out != nil {
		_, err = c.out.Write(buf.Bytes())
		if err != nil {
			errs = append(errs, err)
		}
	}

	// Call each hook
	ent.LoggerName = c.name
	for _, hook := range c.getWriteHooks() {
		if err := hook(ent, logFields, stackErrs, stacktraces); err != nil {
			errs = append(errs, err)
		}
	}

	// Wrap all errors into a multi error
	if len(errs) > 0 {
		err = stackerr.Wrap(multierr.Combine(errs...))
	}

	// If there was an error, return with it
	if err != nil {
		return err
	}
	if ent.Level > zapcore.ErrorLevel {
		// Since we may be crashing the program, sync the output. Ignore Sync
		// errors, pending a clean solution to issue #370.
		c.Sync()
	}
	return nil
}

func (c *core) Sync() error {
	return c.out.Sync()
}
